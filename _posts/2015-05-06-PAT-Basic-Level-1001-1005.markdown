---
layout: post
title: "PAT Basic Level Practice(1001-1010)"
description: "PAT乙级考试练习题"
categories:
- PAT

tags:
- acm
- 

---

* [x] [1001](#ID1001) [1002](#ID1002) [1003](#ID1003) [1004](#ID1004)
* [ ] [1005](#ID1005) [1006](#ID1006) [1007](#ID1007) [1008](#ID1008) [1009](#ID1009) [1010](#ID1010)


>
> <a id="ID1001"> 
> **[1001.害死人不偿命的(3n+1)猜想 (15)][1]**
> </a>
>
> **题意**：任意一个不超过1000的正整数n,偶数则减半，奇数则3*n+1再减半，求多少步变成1.
> 
> **解答**：直接按题意计算，十分简单。
>
> 

~~~c 
#include <stdio.h>

int main(int argc, char *argv[]) 
{
    int n, s = 0;
    scanf("%d",&n);
    
    while (n!=1) 
    {
        n = n%2 ? (3*n+1) / 2 : n / 2;
        s++;
    }
    printf("%d",s);
    
    return 0;
}
~~~

> <a id="ID1002">
> **[1002.写出这个数 (20)][2]**
> </a>
> 
> **题意**：给一个自然数n，n小于10^100,计算各位数字之和，按拼音输出。
> 
> **样例**：
> 
> >1234567890987654321123456789
> >
> >yi san wu
> 
> **解答**：把n的每一位相加得到sum，再根据sum的每一位，输出对应数字拼音.
>

```c
#include<stdio.h>

int main()
{
    char n[102] = {0};
    scanf("%s",n);
    
    int i = 0, sum = 0;  // sum:[0,909]
    while(n[i])
    {
        sum += n[i] - '0';
        i++;
    }
    
    char *str[] = {"ling","yi","er","san","si","wu","liu","qi","ba","jiu"};
    if( sum / 100) printf("%s ",str[sum/100]);
    if( sum / 100 || (sum / 10) % 10 ) printf("%s ",str[(sum/10)%10]);
    printf("%s",str[sum%10]);
    return 0;
}
```

>
><a id="ID1003">
>**[1003. 我要通过！(20)][3]**
></a>
>
> **题意**：给定字符串满足下面条件则答案正确输出YES，否则输出NO.
> 
>> 1. 字符串中必须仅有P, A, T这三种字符，不可以包含其它字符；
> 
>> 2. 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串；
> 
>> 3. 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。
>
>**解答**: 根据xPATx正确，aPbTc在b=A,a=c的情况下正确
>
>而aPbTc正确，则aPbATca正确，则aPbAATcaa正确，依次aPbTc有每次b后扩展一个A则c后扩展一个a
>
>即有aPbA...ATca...a也正确（前后省略个数相同）且aPbA...ATca...a ＝ aPAA...ATaa...a
>
>以上可概括为：
>>1. *字符串中只有P、A、T*
>>
>>2. *P在前T在后,P、T仅出现一次*
>>
>>3. *P前的A个数＊PT间A的个数＝T后面A的个数；PT间A的个数至少有1个*
>>
>

```c
#include<stdio.h>
int ispat(char *strpat)
{
    char *p = 0,*t = 0,*str = strpat;
    int pre_A,mid_A,end_A;
    
    while(*str)
    {
        if(*str == 'P')
        {
            if(!p) p = str;
            else return 0;
            
        }
        else if(*str == 'T')
        {
            if(!t) t = str;
            else return 0;
            
        }
        else if(*str != 'A')
        {
            return 0;
        }
        str++;
    }
    
    if(p >= t) return 0;
    
    pre_A = p - strpat;
    mid_A = t - p - 1;
    end_A = str - t - 1;
    
    if( mid_A < 1 || (pre_A*mid_A) != end_A) return 0;
    
    return 1;
}
int main()
{
    int n;
    scanf("%d",&n);
    
    char str[101] = {0};
    while(n--)
    {
        scanf("%s",str);
        
        if(ispat(str))printf("YES\n");
        else printf("NO\n");
    }
    
    return 0;
}
```

> <a id="ID1004">
> **[1004. 成绩排名 (20)][4]**
> </a>
>
>**题意**：读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号
>
>**解答**：qsort排序即可。注意qsort中compare函数：
>
>>int compare(const void *a, const void *p)
>>
>>return *a - *b; // 1,2,3,4
>>
>>return *b - *a; // 4, 3, 2, 1
>>
>>也就是return值大于0则交换

```c
#include<stdio.h>
#include<stdlib.h>

typedef struct _student
{
    char name[11];
    char NO[11];
    int  score;
}Student;

int compare(const void *p, const void *q)
{
    Student *a = (Student *)p;
    Student *b = (Student *)q;
    
    return a->score - b->score;
}

int main()
{
    Student stu[1000];
    int n, i;
    
    scanf("%d", &n);
    for( i = 0; i < n; i++)
    {
        scanf("%s %s %d",stu[i].name, stu[i].NO, &stu[i].score);
    }
    
    qsort(stu,n,sizeof(stu[0]), compare);
    
    printf("%s %s\n", stu[n-1].name, stu[n-1].NO);
    printf("%s %s\n",stu[0].name, stu[0].NO);
    
    
    return 0;
}

```

>
><a id="ID1005">
>**[1005. 继续(3n+1)猜想 (25)][5]**</a>
>
>

[1]:http://www.patest.cn/contests/pat-b-practise/1001
[2]:http://www.patest.cn/contests/pat-b-practise/1002
[3]:http://www.patest.cn/contests/pat-b-practise/1003
[4]:http://www.patest.cn/contests/pat-b-practise/1004
[5]:http://www.patest.cn/contests/pat-b-practise/1005