---
layout: post
title: "PAT Basic Level Practice(1001-1040)"
description: "PAT乙级考试练习题"
categories:
- PAT

tags:
- acm

---

[PAT Basic Level原题][0]，[Github备份AC代码][1]。刷完40个题，整体简单，代码量小，但想要一次性AC还得留意一些坑点。
	
	1003 比较难想到
	1010 容易忽略0多项式
	  
      
*PAT让我想起了大学时ACM比赛，一直比较菜。如今已脱离行业两三年，偶然遇到PAT，似乎老天在安排什么，笑，吃的盐比当年多了，过的桥也比当年多了，再来做这些练习是不是会得心应手呢？又或是，脑量不足为时已晚！不管怎样，奔着自己AC代码的高兴，奔着企业的绿色通道，干了!*

**1001.害死人不偿命的(3n+1)猜想 (15)**
> 
> *解答：偶数则减半，奇数则3n+1再减半，累加步数，变成1止.*
> 


**1002.写出这个数 (20)**
> 
> *解答：把n的每一位相加得到sum，再根据sum的每一位，输出对应数字拼音.*
>

**1003. 我要通过！(20)**
>
>*解答: 根据xPATx正确，aPbTc在b=A,c=a的情况下也正确.而aPbTc正确，则aPbATca正确，便有aPbAATcaa也正确...也就是aPbTc每次b后扩展一个A则c后扩展一个a都正确，即有aPbA...ATca...a也正确（前后省略个数相同），aPbA...ATca...a ＝ aPAA...ATaa...a，以上可概括为：*
>
>>1. *字符串中只有P、A、T*
>>
>>2. *P在前T在后,P、T仅出现一次*
>>
>>3. *P前的A个数＊PT间A的个数＝T后面A的个数；PT间A的个数至少有1个*
>>
>


**1004. 成绩排名 (20)**
>
>**解答**：qsort排序即可。注意qsort中compare函数：
>
>>int compare(const void *a, const void *b)
>>
>>return *a - *b; // 升序 
>>
>>return *b - *a; // 降序
>>
>>也就是return值大于0则a在b之后
>>
>>如果a,b是double，则要return (*a > *b) ? 1 : -1;
>>

>

**1005. 继续(3n+1)猜想 (25)**
>
>*解答： 哈希法，用key[n]=1先设每个输入的n是关键数，然后对每个n做猜想验证处理，遇到的中间数都标记为非关键数key[n]=0.最后输出key[n]=1的数n.*
>
>

> **1006. 换个格式输出整数 (15)**
> 
> **解答**: 得到n的百、十、个位然后依照条件输出即可，十分简单
> 

**1007. 素数对猜想 (20)**
> 
> *解答: n是否为素数的判定*
>
>> 1. 打一素数表p[]，i = 1; p[i] <= sqrt(n); i++; n%p=0则不为素数。
>>
>> 2. 不打表，效率略低：p = 3; p <= sqrt(n); p += 2; 做n%p
>>  



**1008. 数组元素循环右移问题 (20)**

> *解答: 很简单，另外开一个数组存放移动后的数据。*
>
>>如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？
>
>>刚开始有被这句话误导过，想复杂了，不过貌似到真有一个移动次数更少更节省空间的办法，暂时不管了


**1009. 说反话 (20)**

> *解答:用gets()接受一整行，从后往前扫描，碰到空格意味着跳过了一个单词，输出，直到扫描完整个字符串。*
>
>> 也可以用scanf()单个单词的接收到char *str[];然后从后往前输出。


**1010. 一元多项式求导 (25)**
>
>> *解答: 简单的求导，容易忽略多项式为0,0的情形。*
>

[0]:http://www.patest.cn/contests/pat-b-practise
[1]:https://github.com/lovelife/PAT/tree/master/Basic%20Level%20Practice
